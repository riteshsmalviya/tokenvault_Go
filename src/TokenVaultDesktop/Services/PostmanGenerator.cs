using System.Text.Json;
using TokenVaultDesktop.Models.Postman;

namespace TokenVaultDesktop.Services;

/// <summary>
/// Service for generating Postman Collection JSON files
/// </summary>
public interface IPostmanGenerator
{
    /// <summary>
    /// Generates a Postman collection from the given request
    /// </summary>
    PostmanCollection GenerateCollection(PostmanGenerationRequest request);
    
    /// <summary>
    /// Serializes a collection to JSON
    /// </summary>
    string GenerateJson(PostmanCollection collection);
    
    /// <summary>
    /// Saves a collection to a file
    /// </summary>
    Task SaveToFileAsync(PostmanCollection collection, string filePath);
    
    /// <summary>
    /// Generates and saves a collection in one step
    /// </summary>
    Task<string> GenerateAndSaveAsync(PostmanGenerationRequest request, string filePath);
}

public class PostmanGenerator : IPostmanGenerator
{
    public PostmanCollection GenerateCollection(PostmanGenerationRequest request)
    {
        var collection = new PostmanCollection
        {
            Info = new CollectionInfo
            {
                Name = request.ProjectName,
                Description = request.Description ?? 
                    $"API Collection for {request.ProjectName}\n\nGenerated by TokenVault Desktop\nPort: {request.Port}\nBase URL: {request.ApiBaseUrl}",
                PostmanId = Guid.NewGuid().ToString()
            },
            
            // Collection-level Bearer Token authentication
            Auth = new PostmanAuth
            {
                Type = "bearer",
                Bearer = new List<PostmanAuthParam>
                {
                    new() 
                    { 
                        Key = "token", 
                        Value = "{{token}}", 
                        Type = "string" 
                    }
                }
            },
            
            // Collection-level variables
            Variables = new List<PostmanVariable>
            {
                new() 
                { 
                    Key = "token", 
                    Value = "", 
                    Type = "string",
                    Description = "Bearer token - automatically populated by TokenVault"
                },
                new() 
                { 
                    Key = "baseUrl", 
                    Value = request.ApiBaseUrl, 
                    Type = "string",
                    Description = "Base URL for API requests"
                }
            }
        };
        
        // Add TokenVault pre-request script if requested
        if (request.IncludeTokenVaultScript)
        {
            collection.Events = new List<PostmanEvent>
            {
                new()
                {
                    Listen = "prerequest",
                    Script = new PostmanScript
                    {
                        Type = "text/javascript",
                        Exec = GenerateTokenVaultScript(request.ProjectName)
                    }
                }
            };
        }
        
        // Generate request items for each endpoint
        foreach (var endpoint in request.Endpoints)
        {
            var item = CreateRequestItem(request, endpoint);
            collection.Items.Add(item);
        }
        
        // Add sample endpoints if none provided
        if (!request.Endpoints.Any())
        {
            collection.Items.AddRange(CreateSampleEndpoints(request));
        }
        
        return collection;
    }
    
    private PostmanItem CreateRequestItem(PostmanGenerationRequest request, EndpointDefinition endpoint)
    {
        var baseUrl = request.ApiBaseUrl.TrimEnd('/');
        var path = endpoint.Path.TrimStart('/');
        var fullUrl = $"{baseUrl}/{path}";
        
        var urlParts = ParseUrl(fullUrl);
        
        var item = new PostmanItem
        {
            Name = endpoint.Name,
            Request = new PostmanRequest
            {
                Method = endpoint.Method.ToUpperInvariant(),
                Description = endpoint.Description,
                Url = new PostmanUrl
                {
                    Raw = fullUrl,
                    Protocol = urlParts.Protocol,
                    Host = urlParts.Host,
                    Port = urlParts.Port,
                    Path = urlParts.Path
                },
                Headers = new List<PostmanHeader>
                {
                    new() 
                    { 
                        Key = "Content-Type", 
                        Value = "application/json", 
                        Type = "text" 
                    },
                    new() 
                    { 
                        Key = "Accept", 
                        Value = "application/json", 
                        Type = "text" 
                    }
                }
            }
        };
        
        // Add request-level auth if required
        if (endpoint.RequiresAuth)
        {
            item.Request.Auth = new PostmanAuth
            {
                Type = "bearer",
                Bearer = new List<PostmanAuthParam>
                {
                    new() 
                    { 
                        Key = "token", 
                        Value = "{{token}}", 
                        Type = "string" 
                    }
                }
            };
        }
        
        // Add request body for POST/PUT/PATCH methods
        if (endpoint.Method.ToUpperInvariant() is "POST" or "PUT" or "PATCH")
        {
            item.Request.Body = new PostmanBody
            {
                Mode = "raw",
                Raw = endpoint.RequestBody ?? GenerateDefaultBody(endpoint),
                Options = new PostmanBodyOptions
                {
                    Raw = new PostmanRawOptions { Language = "json" }
                }
            };
        }
        
        return item;
    }
    
    private List<PostmanItem> CreateSampleEndpoints(PostmanGenerationRequest request)
    {
        return new List<PostmanItem>
        {
            CreateRequestItem(request, new EndpointDefinition
            {
                Name = "Health Check",
                Method = "GET",
                Path = "/api/health",
                Description = "Check API health status",
                RequiresAuth = false
            }),
            CreateRequestItem(request, new EndpointDefinition
            {
                Name = "Get Resources",
                Method = "GET",
                Path = "/api/resources",
                Description = "Get all resources",
                RequiresAuth = true
            }),
            CreateRequestItem(request, new EndpointDefinition
            {
                Name = "Create Resource",
                Method = "POST",
                Path = "/api/resources",
                Description = "Create a new resource",
                RequiresAuth = true,
                RequestBody = "{\n  \"name\": \"example\",\n  \"value\": \"sample\"\n}"
            })
        };
    }
    
    private string GenerateDefaultBody(EndpointDefinition endpoint)
    {
        // Generate a sensible default body based on the endpoint path
        var resource = ExtractResourceName(endpoint.Path);
        
        return $@"{{
  ""name"": ""New {resource}"",
  ""description"": ""Description here""
}}";
    }
    
    private string ExtractResourceName(string path)
    {
        var segments = path.Split('/', StringSplitOptions.RemoveEmptyEntries);
        
        // Look for a noun-like segment (skip 'api', 'v1', etc.)
        foreach (var segment in segments)
        {
            if (segment.Length > 2 && 
                !segment.StartsWith('{') && 
                !segment.All(char.IsDigit) &&
                segment.ToLower() is not ("api" or "v1" or "v2"))
            {
                // Singularize simple cases
                if (segment.EndsWith('s') && segment.Length > 3)
                {
                    return char.ToUpper(segment[0]) + segment[1..^1];
                }
                return char.ToUpper(segment[0]) + segment[1..];
            }
        }
        
        return "Item";
    }
    
    private List<string> GenerateTokenVaultScript(string projectName)
    {
        return new List<string>
        {
            "// TokenVault Desktop - Automatic Token Injection",
            $"// Project: {projectName}",
            "",
            "pm.sendRequest({",
            $"    url: 'http://localhost:9999/fetch/{projectName}',",
            "    method: 'GET'",
            "}, function(err, res) {",
            "    if (!err && res.code === 200) {",
            "        var data = res.json();",
            "        pm.collectionVariables.set('token', data.token);",
            $"        console.log('TokenVault: Token updated for {projectName}');",
            "    } else {",
            $"        console.log('TokenVault: Token not found for {projectName}');",
            "    }",
            "});"
        };
    }
    
    private (string Protocol, List<string> Host, string? Port, List<string> Path) ParseUrl(string url)
    {
        try
        {
            var uri = new Uri(url);
            
            return (
                Protocol: uri.Scheme,
                Host: uri.Host.Split('.').ToList(),
                Port: uri.IsDefaultPort ? null : uri.Port.ToString(),
                Path: uri.AbsolutePath.Split('/', StringSplitOptions.RemoveEmptyEntries).ToList()
            );
        }
        catch
        {
            // Fallback for malformed URLs
            return (
                Protocol: "http",
                Host: new List<string> { "localhost" },
                Port: null,
                Path: url.Split('/', StringSplitOptions.RemoveEmptyEntries).ToList()
            );
        }
    }
    
    public string GenerateJson(PostmanCollection collection)
    {
        var options = new JsonSerializerOptions
        {
            WriteIndented = true,
            DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
        };
        
        return JsonSerializer.Serialize(collection, options);
    }
    
    public async Task SaveToFileAsync(PostmanCollection collection, string filePath)
    {
        var json = GenerateJson(collection);
        
        // Ensure directory exists
        var directory = Path.GetDirectoryName(filePath);
        if (!string.IsNullOrEmpty(directory))
        {
            Directory.CreateDirectory(directory);
        }
        
        await File.WriteAllTextAsync(filePath, json);
    }
    
    public async Task<string> GenerateAndSaveAsync(PostmanGenerationRequest request, string filePath)
    {
        var collection = GenerateCollection(request);
        await SaveToFileAsync(collection, filePath);
        return filePath;
    }
}
